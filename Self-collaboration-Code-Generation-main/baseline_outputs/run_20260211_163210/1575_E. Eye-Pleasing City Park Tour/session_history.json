{
  "plan": "```json\n{\n  \"input_output_format_analysis\": {\n    \"input_format\": [\n      \"First line: n k (2 ≤ n ≤ 2×10^5, 0 ≤ k ≤ n-1)\",\n      \"Second line: a_1 a_2 ... a_n (0 ≤ a_i ≤ 10^9)\",\n      \"Next n-1 lines: u_i v_i t_i (1 ≤ u_i, v_i ≤ n, t_i ∈ {0,1})\",\n      \"Edges form a tree\"\n    ],\n    \"output_format\": \"Single integer (sum modulo 10^9+7)\",\n    \"parsing_notes\": [\n      \"Read n, k as integers\",\n      \"Read happiness array as list of integers\",\n      \"Read edges as (u, v, color) where color is 0 (black) or 1 (white)\",\n      \"Build adjacency list with edge colors\"\n    ]\n  },\n  \"algorithm_design\": {\n    \"problem_type\": \"Tree DP / Centroid Decomposition / Path Counting with Color Constraints\",\n    \"core_idea\": \"We need to sum happiness over all simple paths where color switches ≤ k. Equivalent to: For each path, count it if number of color transitions along edges ≤ k.\",\n    \"high_level_approach\": [\n      \"Observation: f(u,v) = sum of a_i for all vertices on path u↔v\",\n      \"Total sum = Σ_{u≤v} Σ_{w∈path(u,v)} a_w = Σ_{w=1}^n a_w × (number of paths containing w that satisfy color constraint)\",\n      \"Thus problem reduces to: For each vertex w, count how many valid paths (u,v) with u≤v contain w\",\n      \"But counting paths containing a vertex with color-switch constraint is complex\",\n      \"Alternative: Use centroid decomposition to count valid paths efficiently\",\n      \"During centroid decomposition, for each centroid C, consider all paths passing through C\",\n      \"For each subtree of C, compute for each path from C to some vertex:\",\n      \"  - Total happiness sum along the path\",\n      \"  - Number of color switches along the path\",\n      \"  - Length of path (number of edges)\",\n      \"Then combine paths from different subtrees using convolution-like counting\"\n    ],\n    \"detailed_steps\": [\n      \"Step 1: Build adjacency list with edge colors\",\n      \"Step 2: Perform centroid decomposition\",\n      \"Step 3: For each centroid C:\",\n      \"  - Initialize DP tables: cnt[switches][last_color] = count of paths, sum_h[switches][last_color] = total happiness\",\n      \"  - For each subtree of C:\",\n      \"    * DFS to collect all paths from C to vertices in subtree\",\n      \"    * For each path record: (switches, last_color, path_happiness, vertex_count)\",\n      \"    * Combine with existing paths from other subtrees:\",\n      \"      For each pair (path1, path2) from different subtrees:\",\n      \"        total_switches = switches1 + switches2 + (last_color1 != last_color2 ? 1 : 0)\",\n      \"        If total_switches ≤ k:\",\n      \"          Contribution = (happiness1 + happiness2 - a_C) × count1 × count2\",\n      \"          (Subtract a_C because it's counted twice)\",\n      \"    * Add current subtree's paths to DP tables\",\n      \"Step 4: Also count single-vertex paths (each vertex alone is valid with 0 switches)\",\n      \"Step 5: Return total sum modulo 1e9+7\"\n    ],\n    \"complexity_analysis\": {\n      \"time\": \"O(n log n × k) with careful implementation\",\n      \"space\": \"O(n × k)\",\n      \"optimization_notes\": \"Can use FFT for convolution if k is large, but k ≤ n so O(nk) might be acceptable with n=2e5, k small\"\n    }\n  },\n  \"edge_cases_and_constraints\": {\n    \"minimum_input\": \"n=2, k=0 or k=1, simple tree\",\n    \"maximum_constraints\": \"n=200,000, k=199,999, large a_i up to 1e9\",\n    \"special_values\": [\n      \"All a_i = 0 → answer is 0\",\n      \"All edges same color → any path valid regardless of k (except k negative)\",\n      \"k = 0 → only monochromatic paths allowed\",\n      \"k = n-1 → all paths valid (maximum switches in any path is n-1)\",\n      \"Tree is a line (path graph)\",\n      \"Tree is star-shaped\"\n    ],\n    \"boundary_conditions\": [\n      \"k can be 0\",\n      \"k can be ≥ n-1 (effectively unlimited)\",\n      \"a_i can be 0\",\n      \"Modulo operation on large sums (use modulo consistently)\",\n      \"Integer overflow in intermediate calculations\"\n    ]\n  },\n  \"common_pitfalls\": [\n    \"Forgetting modulo operations in intermediate steps\",\n    \"Double-counting paths in centroid decomposition\",\n    \"Not handling the case where path starts/ends at centroid properly\",\n    \"Overflow when multiplying counts (use 64-bit integers)\",\n    \"Incorrect switch counting at the junction point in centroid\",\n    \"Time complexity O(n²) if not using centroid decomposition\",\n    \"Memory usage O(n²) if storing all paths naively\",\n    \"Off-by-one in switch counting: first edge doesn't need ticket\",\n    \"Need to count paths with u≤v (not u<v)\",\n    \"Modulo of negative numbers: use (x%MOD + MOD)%MOD\"\n  ],\n  \"additional_notes\": [\n    \"Alternative approach: Rooted tree DP with states (switches, last_color)\",\n    \"But O(nk²) might be too slow for n=2e5\",\n    \"Centroid decomposition reduces to O(n log n × k)\",\n    \"Can optimize with prefix sums for switch counts\",\n    \"Test with provided examples: first output 45, second output 10\",\n    \"Consider using 0-based or 1-based indexing consistently\"\n  ]\n}\n```",
  "Round_0": {
    "code": "def solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    k = int(next(it))\n    a = [0] * n\n    for i in range(n):\n        a[i] = int(next(it))\n    \n    adj = [[] for _ in range(n)]\n    for _ in range(n-1):\n        u = int(next(it)) - 1\n        v = int(next(it)) - 1\n        t = int(next(it))\n        adj[u].append((v, t))\n        adj[v].append((u, t))\n    \n    # centroid decomposition\n    removed = [False] * n\n    subtree_size = [0] * n\n    \n    def dfs_size(v, p):\n        subtree_size[v] = 1\n        for to, _ in adj[v]:\n            if to != p and not removed[to]:\n                dfs_size(to, v)\n                subtree_size[v] += subtree_size[to]\n    \n    def find_centroid(v, p, total):\n        for to, _ in adj[v]:\n            if to != p and not removed[to] and subtree_size[to] * 2 > total:\n                return find_centroid(to, v, total)\n        return v\n    \n    ans = 0\n    \n    # single vertex paths\n    for val in a:\n        ans = (ans + val) % MOD\n    \n    # paths through centroid\n    def process_centroid(centroid):\n        nonlocal ans\n        # cnt[sw][col] = number of paths from centroid to some vertex\n        # sum_h[sw][col] = total happiness sum of those paths\n        cnt = [[0, 0] for _ in range(k+2)]\n        sum_h = [[0, 0] for _ in range(k+2)]\n        \n        # start with centroid itself (path of length 0)\n        cnt[0][0] = 1  # color doesn't matter for length 0, use 0 as default\n        sum_h[0][0] = a[centroid] % MOD\n        \n        for to, col in adj[centroid]:\n            if removed[to]:\n                continue\n            \n            # collect all paths in this subtree\n            paths = []  # (switches, last_color, happiness, count)\n            \n            stack = [(to, centroid, col, 1, a[to], col)]\n            while stack:\n                v, p, last_col, sw, happiness, first_col = stack.pop()\n                # record this path\n                if sw <= k:\n                    paths.append((sw, last_col, happiness % MOD, 1))\n                # continue DFS\n                for nxt, edge_col in adj[v]:\n                    if nxt == p or removed[nxt]:\n                        continue\n                    new_sw = sw + (1 if edge_col != last_col else 0)\n                    new_happiness = happiness + a[nxt]\n                    stack.append((nxt, v, edge_col, new_sw, new_happiness, first_col))\n            \n            # combine with previous subtrees\n            for sw1, col1, h1, c1 in paths:\n                for sw2 in range(k+1):\n                    for col2 in range(2):\n                        c2 = cnt[sw2][col2]\n                        if c2 == 0:\n                            continue\n                        total_sw = sw1 + sw2\n                        if col1 != col2:\n                            total_sw += 1\n                        if total_sw <= k:\n                            # happiness contribution: (h1 + h2 - a[centroid]) * c1 * c2\n                            h2 = sum_h[sw2][col2]\n                            total_h = (h1 + h2 - a[centroid]) % MOD\n                            contribution = (total_h * c1 % MOD) * c2 % MOD\n                            ans = (ans + contribution) % MOD\n            \n            # add current subtree paths to cnt/sum_h\n            for sw, col, h, c in paths:\n                cnt[sw][col] = (cnt[sw][col] + c) % MOD\n                sum_h[sw][col] = (sum_h[sw][col] + h) % MOD\n        \n        # also count paths that start at centroid and go into one subtree\n        # (these were counted as single vertex already, but we need paths of length >=1)\n        # Actually, single vertex is already counted at the beginning.\n        # For paths from centroid to some vertex in a subtree:\n        # They are valid if switches <= k\n        # Their contribution is the path happiness * 1 (paired with centroid as other endpoint)\n        # But careful: we already counted single vertex paths.\n        # Let's count paths where the other endpoint is centroid itself:\n        # That's just the single vertex path, already counted.\n        # So we need paths where both endpoints are not centroid? Actually in our combine step\n        # we already counted all pairs from different subtrees, which includes paths where\n        # one endpoint is centroid? Wait, centroid is the \"center\" but not necessarily endpoint.\n        # In centroid decomposition, we consider paths passing through centroid.\n        # A path from centroid to vertex v in subtree S: this path has one endpoint at centroid.\n        # When we combine with \"empty path from centroid\" (which is in cnt), we get\n        # paths from centroid to v. But we must not double count single vertex.\n        # Actually, we should count all paths with centroid as one endpoint separately.\n        # Let's do that now:\n        for sw in range(k+1):\n            for col in range(2):\n                c = cnt[sw][col]\n                if c == 0:\n                    continue\n                # paths from centroid to some vertex (including centroid itself)\n                # but subtract the centroid itself which was counted as single vertex\n                if sw == 0 and col == 0:\n                    # this is the centroid itself (path length 0)\n                    # we already counted it, so skip\n                    pass\n                else:\n                    h = sum_h[sw][col]\n                    # contribution: happiness sum of path * 1 (other endpoint is centroid)\n                    # Actually, for path (centroid, v), f(centroid,v) = h\n                    # We need to count it once (since u<=v, and centroid <= v or v <= centroid?)\n                    # Since we consider all pairs u<=v, we should count both (centroid,v) and (v,centroid)\n                    # But our total sum is over u<=v, so if centroid != v, we count only one of them.\n                    # However, in the problem, f(u,v) is defined for u≤v.\n                    # So for centroid != v, we need to know if centroid < v or v < centroid.\n                    # That's messy. Better to count all ordered pairs (u,v) with u<=v.\n                    # Let's think differently: In centroid decomposition, when we process centroid C,\n                    # we consider all paths passing through C. A path (u,v) with u<v that passes through C\n                    # will be counted exactly once when C is the first centroid on that path.\n                    # So we should count all such paths where C is the \"highest\" centroid.\n                    # For paths where C is an endpoint, they also pass through C.\n                    # So we should count them here.\n                    # The path (C, v) has happiness h (which includes a[C] + ... + a[v]).\n                    # We need to add h to answer.\n                    # But careful: we already added single vertex paths. So for v=C, skip.\n                    # For v≠C, add h.\n                    # However, our cnt[sw][col] includes multiple vertices. We need to subtract\n                    # the centroid itself which is in cnt[0][0].\n                    # Actually easier: just add all h from cnt, then subtract a[C] for the\n                    # centroid itself entry.\n                    # But wait, h in sum_h[sw][col] is total happiness of all paths from C\n                    # to vertices in subtree with given (sw,col). So adding all h gives\n                    # sum over v of f(C,v). But we need f(C,v) for v>C? Actually we need\n                    # f(C,v) for all v (since C might be less than or greater than v).\n                    # Since we sum over u<=v, we should only count pairs where C <= v.\n                    # That depends on vertex numbering. This is getting too complex.\n                    # Alternative: Count all ordered pairs (u,v) with u<v, then at the end\n                    # add single vertices. Then divide by issues...\n                    # Let's follow the standard centroid decomposition approach:\n                    # We count all unordered pairs (u,v) with u≠v, then add single vertices.\n                    # Then we don't care about u<=v, we just need sum of f(u,v) over all unordered pairs.\n                    # Since f(u,v) = f(v,u), and we want sum over u<=v, we can compute sum over\n                    # all unordered pairs, then add single vertices (f(u,u)=a[u]).\n                    # So let's compute sum over all unordered pairs u≠v.\n                    # In centroid decomposition, we count each unordered pair exactly once.\n                    # So we can just compute sum over all unordered pairs passing through centroid.\n                    # For paths where centroid is endpoint, they are also unordered pairs.\n                    # So we should count them.\n                    # In our combine step, we counted pairs from different subtrees.\n                    # That doesn't include pairs where one endpoint is centroid.\n                    # So we need to add those separately.\n                    # For each path from centroid to v (v≠centroid), the pair is (centroid,v).\n                    # Its contribution is h (which includes a[centroid] + ... + a[v]).\n                    # So we add h for each such v.\n                    # But our cnt includes the centroid itself. So we need to subtract that.\n                    # Let's compute total_h_all = sum over all sum_h[sw][col]\n                    # Subtract a[centroid] (for the centroid itself)\n                    # That gives sum over v≠centroid of f(centroid,v).\n                    # Add that to ans.\n                    pass\n        \n        # Actually, let's compute it properly:\n        total_h_all = 0\n        total_cnt_all = 0\n        for sw in range(k+1):\n            for col in range(2):\n                total_h_all = (total_h_all + sum_h[sw][col]) % MOD\n                total_cnt_all = (total_cnt_all + cnt[sw][col]) % MOD\n        # total_h_all = sum of happiness of all paths from centroid to some vertex (including centroid)\n        # Subtract the centroid itself:\n        centroid_contrib = (total_h_all - a[centroid]) % MOD\n        ans = (ans + centroid_contrib) % MOD\n    \n    def decompose(v):\n        dfs_size(v, -1)\n        cent = find_centroid(v, -1, subtree_size[v])\n        process_centroid(cent)\n        removed[cent] = True\n        for to, _ in adj[cent]:\n            if not removed[to]:\n                decompose(to)\n    \n    decompose(0)\n    print(ans % MOD)",
    "report": "The compilation output of the preceding code is: Test Case 1 Failed:\n  Status: RE\n  Input:\n2 0\n5 10\n1 2 0\n  Expected:\n25\n  Actual Output:\n\n  Error: Traceback (most recent call last):\n  File \"C:\\Users\\杨文韬\\AppData\\Local\\Temp\\tmp7tyqe8gi\\solution.py\", line 209, in <module>\n    solve()\n  File \"C:\\Users\\杨文韬\\AppData\\Local\\Temp\\tmp7tyqe8gi\\solution.py\", line 43, in solve\n    ans = (ans + val) % MOD\n                        ^^^\nNameError: name 'MOD' is not defined\n\n\nTest Case 2 Failed:\n  Status: RE\n  Input:\n2 1\n5 10\n1 2 1\n  Expected:\n25\n  Actual Output:\n\n  Error: Traceback (most recent call last):\n  File \"C:\\Users\\杨文韬\\AppData\\Local\\Temp\\tmp9r2de5d2\\solution.py\", line 209, in <module>\n    solve()\n  File \"C:\\Users\\杨文韬\\AppData\\Local\\Temp\\tmp9r2de5d2\\solution.py\", line 43, in solve\n    ans = (ans + val) % MOD\n                        ^^^\nNameError: name 'MOD' is not defined\n\n\nTest Case 3 Failed:\n  Status: RE\n  Input:\n3 0\n1 2 3\n1 2 0\n2 3 0\n  Expected:\n20\n  Actual Output:\n\n  Error: Traceback (most recent call last):\n  File \"C:\\Users\\杨文韬\\AppData\\Local\\Temp\\tmpcxfo3pg_\\solution.py\", line 209, in <module>\n    solve()\n  File \"C:\\Users\\杨文韬\\AppData\\Local\\Temp\\tmpcxfo3pg_\\solution.py\", line 43, in solve\n    ans = (ans + val) % MOD\n                        ^^^\nNameError: name 'MOD' is not defined\n\n\nTest Case 4 Failed:\n  Status: RE\n  Input:\n3 1\n1 2 3\n1 2 0\n2 3 1\n  Expected:\n23\n  Actual Output:\n\n  Error: Traceback (most recent call last):\n  File \"C:\\Users\\杨文韬\\AppData\\Local\\Temp\\tmp79lc8_n8\\solution.py\", line 209, in <module>\n    solve()\n  File \"C:\\Users\\杨文韬\\AppData\\Local\\Temp\\tmp79lc8_n8\\solution.py\", line 43, in solve\n    ans = (ans + val) % MOD\n                        ^^^\nNameError: name 'MOD' is not defined\n\n\nTest Case 5 Failed:\n  Status: RE\n  Input:\n4 1\n1 1 1 1\n1 2 0\n2 3 1\n3 4 0\n  Expected:\n30\n  Actual Output:\n\n  Error: Traceback (most recent call last):\n  File \"C:\\Users\\杨文韬\\AppData\\Local\\Temp\\tmpg3emioph\\solution.py\", line 209, in <module>\n    solve()\n  File \"C:\\Users\\杨文韬\\AppData\\Local\\Temp\\tmpg3emioph\\solution.py\", line 43, in solve\n    ans = (ans + val) % MOD\n                        ^^^\nNameError: name 'MOD' is not defined\n\n\nTest Case 6 Failed:\n  Status: RE\n  Input:\n5 2\n0 0 0 0 0\n1 2 0\n2 3 1\n3 4 0\n4 5 1\n  Expected:\n0\n  Actual Output:\n\n  Error: Traceback (most recent call last):\n  File \"C:\\Users\\杨文韬\\AppData\\Local\\Temp\\tmpxgqeaerv\\solution.py\", line 209, in <module>\n    solve()\n  File \"C:\\Users\\杨文韬\\AppData\\Local\\Temp\\tmpxgqeaerv\\solution.py\", line 43, in solve\n    ans = (ans + val) % MOD\n                        ^^^\nNameError: name 'MOD' is not defined\n\n\nTest Case 7 Failed:\n  Status: RE\n  Input:\n5 0\n1 3 2 6 4\n1 2 1\n1 4 0\n3 2 1\n2 5 0\n  Expected:\n45\n  Actual Output:\n\n  Error: Traceback (most recent call last):\n  File \"C:\\Users\\杨文韬\\AppData\\Local\\Temp\\tmpn81krlrk\\solution.py\", line 209, in <module>\n    solve()\n  File \"C:\\Users\\杨文韬\\AppData\\Local\\Temp\\tmpn81krlrk\\solution.py\", line 43, in solve\n    ans = (ans + val) % MOD\n                        ^^^\nNameError: name 'MOD' is not defined\n\n\nTest Case 8 Failed:\n  Status: RE\n  Input:\n3 1\n1 1 1\n1 2 1\n3 2 0\n  Expected:\n10\n  Actual Output:\n\n  Error: Traceback (most recent call last):\n  File \"C:\\Users\\杨文韬\\AppData\\Local\\Temp\\tmp75ohdv9c\\solution.py\", line 209, in <module>\n    solve()\n  File \"C:\\Users\\杨文韬\\AppData\\Local\\Temp\\tmp75ohdv9c\\solution.py\", line 43, in solve\n    ans = (ans + val) % MOD\n                        ^^^\nNameError: name 'MOD' is not defined\n\n\nTest Case 9 Failed:\n  Status: RE\n  Input:\n6 3\n1000000000 1000000000 1000000000 1000000000 1000000000 1000000000\n1 2 0\n2 3 1\n3 4 0\n4 5 1\n5 6 0\n  Expected:\n999999918\n  Actual Output:\n\n  Error: Traceback (most recent call last):\n  File \"C:\\Users\\杨文韬\\AppData\\Local\\Temp\\tmpg_m8ph5u\\solution.py\", line 209, in <module>\n    solve()\n  File \"C:\\Users\\杨文韬\\AppData\\Local\\Temp\\tmpg_m8ph5u\\solution.py\", line 43, in solve\n    ans = (ans + val) % MOD\n                        ^^^\nNameError: name 'MOD' is not defined\n\n",
    "tests": "```\nInput:\n2 0\n5 10\n1 2 0\n\nOutput:\n25\n```\n\n```\nInput:\n2 1\n5 10\n1 2 1\n\nOutput:\n25\n```\n\n```\nInput:\n3 0\n1 2 3\n1 2 0\n2 3 0\n\nOutput:\n20\n```\n\n```\nInput:\n3 1\n1 2 3\n1 2 0\n2 3 1\n\nOutput:\n23\n```\n\n```\nInput:\n4 1\n1 1 1 1\n1 2 0\n2 3 1\n3 4 0\n\nOutput:\n30\n```\n\n```\nInput:\n5 2\n0 0 0 0 0\n1 2 0\n2 3 1\n3 4 0\n4 5 1\n\nOutput:\n0\n```\n\n```\nInput:\n5 0\n1 3 2 6 4\n1 2 1\n1 4 0\n3 2 1\n2 5 0\n\nOutput:\n45\n```\n\n```\nInput:\n3 1\n1 1 1\n1 2 1\n3 2 0\n\nOutput:\n10\n```\n\n```\nInput:\n6 3\n1000000000 1000000000 1000000000 1000000000 1000000000 1000000000\n1 2 0\n2 3 1\n3 4 0\n4 5 1\n5 6 0\n\nOutput:\n999999918\n```",
    "test_report": "Input:\n2 0\n5 10\n1 2 0\n\nOutput:\n25\n"
  },
  "Round_1": {
    "code": "def solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    k = int(next(it))\n    a = [0] * n\n    for i in range(n):\n        a[i] = int(next(it))\n    \n    adj = [[] for _ in range(n)]\n    for _ in range(n-1):\n        u = int(next(it)) - 1\n        v = int(next(it)) - 1\n        t = int(next(it))\n        adj[u].append((v, t))\n        adj[v].append((u, t))\n    \n    removed = [False] * n\n    subtree_size = [0] * n\n    \n    def dfs_size(v, p):\n        subtree_size[v] = 1\n        for to, _ in adj[v]:\n            if to != p and not removed[to]:\n                dfs_size(to, v)\n                subtree_size[v] += subtree_size[to]\n    \n    def find_centroid(v, p, total):\n        for to, _ in adj[v]:\n            if to != p and not removed[to] and subtree_size[to] * 2 > total:\n                return find_centroid(to, v, total)\n        return v\n    \n    ans = 0\n    \n    # single vertex paths\n    for val in a:\n        ans = (ans + val) % MOD\n    \n    # paths through centroid\n    def process_centroid(centroid):\n        nonlocal ans\n        \n        # cnt[sw][col] = number of paths from centroid to some vertex\n        # sum_h[sw][col] = total happiness sum of those paths\n        cnt = [[0, 0] for _ in range(k+2)]\n        sum_h = [[0, 0] for _ in range(k+2)]\n        \n        # start with centroid itself (path of length 0)\n        cnt[0][0] = 1\n        sum_h[0][0] = a[centroid] % MOD\n        \n        for to, first_col in adj[centroid]:\n            if removed[to]:\n                continue\n            \n            # collect all paths in this subtree\n            paths = []  # (switches, last_color, happiness, count)\n            \n            stack = [(to, centroid, first_col, 0, a[to] + a[centroid], first_col)]\n            while stack:\n                v, p, last_col, sw, happiness, first_col = stack.pop()\n                # record this path\n                if sw <= k:\n                    paths.append((sw, last_col, happiness % MOD, 1))\n                # continue DFS\n                for nxt, edge_col in adj[v]:\n                    if nxt == p or removed[nxt]:\n                        continue\n                    new_sw = sw + (1 if edge_col != last_col else 0)\n                    new_happiness = happiness + a[nxt]\n                    stack.append((nxt, v, edge_col, new_sw, new_happiness, first_col))\n            \n            # combine with previous subtrees\n            for sw1, col1, h1, c1 in paths:\n                for sw2 in range(k+1):\n                    for col2 in range(2):\n                        c2 = cnt[sw2][col2]\n                        if c2 == 0:\n                            continue\n                        total_sw = sw1 + sw2\n                        if col1 != col2:\n                            total_sw += 1\n                        if total_sw <= k:\n                            # happiness contribution: (h1 + h2 - a[centroid]) * c1 * c2\n                            h2 = sum_h[sw2][col2]\n                            total_h = (h1 + h2 - a[centroid]) % MOD\n                            contribution = (total_h * c1) % MOD\n                            contribution = (contribution * c2) % MOD\n                            ans = (ans + contribution) % MOD\n            \n            # add current subtree paths to cnt/sum_h\n            for sw, col, h, c in paths:\n                cnt[sw][col] = (cnt[sw][col] + c) % MOD\n                sum_h[sw][col] = (sum_h[sw][col] + h) % MOD\n        \n        # add paths where centroid is one endpoint\n        total_h_all = 0\n        for sw in range(k+1):\n            for col in range(2):\n                total_h_all = (total_h_all + sum_h[sw][col]) % MOD\n        # subtract centroid itself (already counted as single vertex)\n        centroid_contrib = (total_h_all - a[centroid]) % MOD\n        ans = (ans + centroid_contrib) % MOD\n    \n    def decompose(v):\n        dfs_size(v, -1)\n        cent = find_centroid(v, -1, subtree_size[v])\n        process_centroid(cent)\n        removed[cent] = True\n        for to, _ in adj[cent]:\n            if not removed[to]:\n                decompose(to)\n    \n    decompose(0)\n    print(ans % MOD)",
    "report": "The compilation output of the preceding code is: Test Case 1 Failed:\n  Status: RE\n  Input:\n2 0\n5 10\n1 2 0\n  Expected:\n25\n  Actual Output:\n\n  Error: Traceback (most recent call last):\n  File \"C:\\Users\\杨文韬\\AppData\\Local\\Temp\\tmpxpv5q5fo\\solution.py\", line 209, in <module>\n    solve()\n  File \"C:\\Users\\杨文韬\\AppData\\Local\\Temp\\tmpxpv5q5fo\\solution.py\", line 43, in solve\n    ans = (ans + val) % MOD\n                        ^^^\nNameError: name 'MOD' is not defined\n\n\nTest Case 2 Failed:\n  Status: RE\n  Input:\n2 1\n5 10\n1 2 1\n  Expected:\n25\n  Actual Output:\n\n  Error: Traceback (most recent call last):\n  File \"C:\\Users\\杨文韬\\AppData\\Local\\Temp\\tmp9mm1x0ud\\solution.py\", line 209, in <module>\n    solve()\n  File \"C:\\Users\\杨文韬\\AppData\\Local\\Temp\\tmp9mm1x0ud\\solution.py\", line 43, in solve\n    ans = (ans + val) % MOD\n                        ^^^\nNameError: name 'MOD' is not defined\n\n\nTest Case 3 Failed:\n  Status: RE\n  Input:\n3 0\n1 2 3\n1 2 0\n2 3 0\n  Expected:\n20\n  Actual Output:\n\n  Error: Traceback (most recent call last):\n  File \"C:\\Users\\杨文韬\\AppData\\Local\\Temp\\tmp97goo1tr\\solution.py\", line 209, in <module>\n    solve()\n  File \"C:\\Users\\杨文韬\\AppData\\Local\\Temp\\tmp97goo1tr\\solution.py\", line 43, in solve\n    ans = (ans + val) % MOD\n                        ^^^\nNameError: name 'MOD' is not defined\n\n\nTest Case 4 Failed:\n  Status: RE\n  Input:\n3 1\n1 2 3\n1 2 0\n2 3 1\n  Expected:\n23\n  Actual Output:\n\n  Error: Traceback (most recent call last):\n  File \"C:\\Users\\杨文韬\\AppData\\Local\\Temp\\tmpecwj9qnw\\solution.py\", line 209, in <module>\n    solve()\n  File \"C:\\Users\\杨文韬\\AppData\\Local\\Temp\\tmpecwj9qnw\\solution.py\", line 43, in solve\n    ans = (ans + val) % MOD\n                        ^^^\nNameError: name 'MOD' is not defined\n\n\nTest Case 5 Failed:\n  Status: RE\n  Input:\n4 1\n1 1 1 1\n1 2 0\n2 3 1\n3 4 0\n  Expected:\n30\n  Actual Output:\n\n  Error: Traceback (most recent call last):\n  File \"C:\\Users\\杨文韬\\AppData\\Local\\Temp\\tmps28n96py\\solution.py\", line 209, in <module>\n    solve()\n  File \"C:\\Users\\杨文韬\\AppData\\Local\\Temp\\tmps28n96py\\solution.py\", line 43, in solve\n    ans = (ans + val) % MOD\n                        ^^^\nNameError: name 'MOD' is not defined\n\n\nTest Case 6 Failed:\n  Status: RE\n  Input:\n5 2\n0 0 0 0 0\n1 2 0\n2 3 1\n3 4 0\n4 5 1\n  Expected:\n0\n  Actual Output:\n\n  Error: Traceback (most recent call last):\n  File \"C:\\Users\\杨文韬\\AppData\\Local\\Temp\\tmpk0ui1ly9\\solution.py\", line 209, in <module>\n    solve()\n  File \"C:\\Users\\杨文韬\\AppData\\Local\\Temp\\tmpk0ui1ly9\\solution.py\", line 43, in solve\n    ans = (ans + val) % MOD\n                        ^^^\nNameError: name 'MOD' is not defined\n\n\nTest Case 7 Failed:\n  Status: RE\n  Input:\n5 0\n1 3 2 6 4\n1 2 1\n1 4 0\n3 2 1\n2 5 0\n  Expected:\n45\n  Actual Output:\n\n  Error: Traceback (most recent call last):\n  File \"C:\\Users\\杨文韬\\AppData\\Local\\Temp\\tmpi0angdlr\\solution.py\", line 209, in <module>\n    solve()\n  File \"C:\\Users\\杨文韬\\AppData\\Local\\Temp\\tmpi0angdlr\\solution.py\", line 43, in solve\n    ans = (ans + val) % MOD\n                        ^^^\nNameError: name 'MOD' is not defined\n\n\nTest Case 8 Failed:\n  Status: RE\n  Input:\n3 1\n1 1 1\n1 2 1\n3 2 0\n  Expected:\n10\n  Actual Output:\n\n  Error: Traceback (most recent call last):\n  File \"C:\\Users\\杨文韬\\AppData\\Local\\Temp\\tmpkmpkw_uv\\solution.py\", line 209, in <module>\n    solve()\n  File \"C:\\Users\\杨文韬\\AppData\\Local\\Temp\\tmpkmpkw_uv\\solution.py\", line 43, in solve\n    ans = (ans + val) % MOD\n                        ^^^\nNameError: name 'MOD' is not defined\n\n\nTest Case 9 Failed:\n  Status: RE\n  Input:\n6 3\n1000000000 1000000000 1000000000 1000000000 1000000000 1000000000\n1 2 0\n2 3 1\n3 4 0\n4 5 1\n5 6 0\n  Expected:\n999999918\n  Actual Output:\n\n  Error: Traceback (most recent call last):\n  File \"C:\\Users\\杨文韬\\AppData\\Local\\Temp\\tmp40go16qc\\solution.py\", line 209, in <module>\n    solve()\n  File \"C:\\Users\\杨文韬\\AppData\\Local\\Temp\\tmp40go16qc\\solution.py\", line 43, in solve\n    ans = (ans + val) % MOD\n                        ^^^\nNameError: name 'MOD' is not defined\n\n",
    "tests": "```\nInput:\n2 0\n5 10\n1 2 0\n\nOutput:\n25\n```\n\n```\nInput:\n2 1\n5 10\n1 2 1\n\nOutput:\n25\n```\n\n```\nInput:\n3 0\n1 2 3\n1 2 0\n2 3 0\n\nOutput:\n20\n```\n\n```\nInput:\n3 1\n1 2 3\n1 2 0\n2 3 1\n\nOutput:\n23\n```\n\n```\nInput:\n4 1\n1 1 1 1\n1 2 0\n2 3 1\n3 4 0\n\nOutput:\n30\n```\n\n```\nInput:\n5 2\n0 0 0 0 0\n1 2 0\n2 3 1\n3 4 0\n4 5 1\n\nOutput:\n0\n```\n\n```\nInput:\n5 0\n1 3 2 6 4\n1 2 1\n1 4 0\n3 2 1\n2 5 0\n\nOutput:\n45\n```\n\n```\nInput:\n3 1\n1 1 1\n1 2 1\n3 2 0\n\nOutput:\n10\n```\n\n```\nInput:\n6 3\n1000000000 1000000000 1000000000 1000000000 1000000000 1000000000\n1 2 0\n2 3 1\n3 4 0\n4 5 1\n5 6 0\n\nOutput:\n999999918\n```",
    "test_report": "Input:\n2 0\n5 10\n1 2 0\n\nOutput:\n25\n"
  },
  "Round_2": {
    "code": "def solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    k = int(next(it))\n    a = [0] * n\n    for i in range(n):\n        a[i] = int(next(it))\n    \n    adj = [[] for _ in range(n)]\n    for _ in range(n-1):\n        u = int(next(it)) - 1\n        v = int(next(it)) - 1\n        t = int(next(it))\n        adj[u].append((v, t))\n        adj[v].append((u, t))\n    \n    removed = [False] * n\n    subtree_size = [0] * n\n    \n    def dfs_size(v, p):\n        subtree_size[v] = 1\n        for to, _ in adj[v]:\n            if to != p and not removed[to]:\n                dfs_size(to, v)\n                subtree_size[v] += subtree_size[to]\n    \n    def find_centroid(v, p, total):\n        for to, _ in adj[v]:\n            if to != p and not removed[to] and subtree_size[to] * 2 > total:\n                return find_centroid(to, v, total)\n        return v\n    \n    ans = 0\n    \n    # single vertex paths\n    for val in a:\n        ans = (ans + val) % MOD\n    \n    # paths through centroid\n    def process_centroid(centroid):\n        nonlocal ans\n        \n        # cnt[sw][col] = number of paths from centroid to some vertex\n        # sum_h[sw][col] = total happiness sum of those paths\n        cnt = [[0, 0] for _ in range(k+2)]\n        sum_h = [[0, 0] for _ in range(k+2)]\n        \n        # start with centroid itself (path of length 0)\n        cnt[0][0] = 1\n        sum_h[0][0] = a[centroid] % MOD\n        \n        for to, first_col in adj[centroid]:\n            if removed[to]:\n                continue\n            \n            # collect all paths in this subtree\n            paths = []  # (switches, last_color, happiness, count)\n            \n            stack = [(to, centroid, first_col, 0, a[to] + a[centroid], first_col)]\n            while stack:\n                v, p, last_col, sw, happiness, first_col = stack.pop()\n                # record this path\n                if sw <= k:\n                    paths.append((sw, last_col, happiness % MOD, 1))\n                # continue DFS\n                for nxt, edge_col in adj[v]:\n                    if nxt == p or removed[nxt]:\n                        continue\n                    new_sw = sw + (1 if edge_col != last_col else 0)\n                    new_happiness = happiness + a[nxt]\n                    stack.append((nxt, v, edge_col, new_sw, new_happiness, first_col))\n            \n            # combine with previous subtrees\n            for sw1, col1, h1, c1 in paths:\n                for sw2 in range(k+1):\n                    for col2 in range(2):\n                        c2 = cnt[sw2][col2]\n                        if c2 == 0:\n                            continue\n                        total_sw = sw1 + sw2\n                        if col1 != col2:\n                            total_sw += 1\n                        if total_sw <= k:\n                            # happiness contribution: (h1 + h2 - a[centroid]) * c1 * c2\n                            h2 = sum_h[sw2][col2]\n                            total_h = (h1 + h2 - a[centroid]) % MOD\n                            contribution = (total_h * c1) % MOD\n                            contribution = (contribution * c2) % MOD\n                            ans = (ans + contribution) % MOD\n            \n            # add current subtree paths to cnt/sum_h\n            for sw, col, h, c in paths:\n                cnt[sw][col] = (cnt[sw][col] + c) % MOD\n                sum_h[sw][col] = (sum_h[sw][col] + h) % MOD\n        \n        # add paths where centroid is one endpoint\n        total_h_all = 0\n        for sw in range(k+1):\n            for col in range(2):\n                total_h_all = (total_h_all + sum_h[sw][col]) % MOD\n        # subtract centroid itself (already counted as single vertex)\n        centroid_contrib = (total_h_all - a[centroid]) % MOD\n        ans = (ans + centroid_contrib) % MOD\n    \n    def decompose(v):\n        dfs_size(v, -1)\n        cent = find_centroid(v, -1, subtree_size[v])\n        process_centroid(cent)\n        removed[cent] = True\n        for to, _ in adj[cent]:\n            if not removed[to]:\n                decompose(to)\n    \n    decompose(0)\n    print(ans % MOD)",
    "report": "The compilation output of the preceding code is: Test Case 1 Failed:\n  Status: RE\n  Input:\n2 0\n5 10\n1 2 0\n  Expected:\n25\n  Actual Output:\n\n  Error: Traceback (most recent call last):\n  File \"C:\\Users\\杨文韬\\AppData\\Local\\Temp\\tmprd3iwec9\\solution.py\", line 123, in <module>\n    solve()\n  File \"C:\\Users\\杨文韬\\AppData\\Local\\Temp\\tmprd3iwec9\\solution.py\", line 42, in solve\n    ans = (ans + val) % MOD\n                        ^^^\nNameError: name 'MOD' is not defined\n\n\nTest Case 2 Failed:\n  Status: RE\n  Input:\n2 1\n5 10\n1 2 1\n  Expected:\n25\n  Actual Output:\n\n  Error: Traceback (most recent call last):\n  File \"C:\\Users\\杨文韬\\AppData\\Local\\Temp\\tmp54pf1il_\\solution.py\", line 123, in <module>\n    solve()\n  File \"C:\\Users\\杨文韬\\AppData\\Local\\Temp\\tmp54pf1il_\\solution.py\", line 42, in solve\n    ans = (ans + val) % MOD\n                        ^^^\nNameError: name 'MOD' is not defined\n\n\nTest Case 3 Failed:\n  Status: RE\n  Input:\n3 0\n1 2 3\n1 2 0\n2 3 0\n  Expected:\n20\n  Actual Output:\n\n  Error: Traceback (most recent call last):\n  File \"C:\\Users\\杨文韬\\AppData\\Local\\Temp\\tmp85cg0fa3\\solution.py\", line 123, in <module>\n    solve()\n  File \"C:\\Users\\杨文韬\\AppData\\Local\\Temp\\tmp85cg0fa3\\solution.py\", line 42, in solve\n    ans = (ans + val) % MOD\n                        ^^^\nNameError: name 'MOD' is not defined\n\n\nTest Case 4 Failed:\n  Status: RE\n  Input:\n3 1\n1 2 3\n1 2 0\n2 3 1\n  Expected:\n23\n  Actual Output:\n\n  Error: Traceback (most recent call last):\n  File \"C:\\Users\\杨文韬\\AppData\\Local\\Temp\\tmpdund5ono\\solution.py\", line 123, in <module>\n    solve()\n  File \"C:\\Users\\杨文韬\\AppData\\Local\\Temp\\tmpdund5ono\\solution.py\", line 42, in solve\n    ans = (ans + val) % MOD\n                        ^^^\nNameError: name 'MOD' is not defined\n\n\nTest Case 5 Failed:\n  Status: RE\n  Input:\n4 1\n1 1 1 1\n1 2 0\n2 3 1\n3 4 0\n  Expected:\n30\n  Actual Output:\n\n  Error: Traceback (most recent call last):\n  File \"C:\\Users\\杨文韬\\AppData\\Local\\Temp\\tmpno013c4c\\solution.py\", line 123, in <module>\n    solve()\n  File \"C:\\Users\\杨文韬\\AppData\\Local\\Temp\\tmpno013c4c\\solution.py\", line 42, in solve\n    ans = (ans + val) % MOD\n                        ^^^\nNameError: name 'MOD' is not defined\n\n\nTest Case 6 Failed:\n  Status: RE\n  Input:\n5 2\n0 0 0 0 0\n1 2 0\n2 3 1\n3 4 0\n4 5 1\n  Expected:\n0\n  Actual Output:\n\n  Error: Traceback (most recent call last):\n  File \"C:\\Users\\杨文韬\\AppData\\Local\\Temp\\tmp_i4i_9sx\\solution.py\", line 123, in <module>\n    solve()\n  File \"C:\\Users\\杨文韬\\AppData\\Local\\Temp\\tmp_i4i_9sx\\solution.py\", line 42, in solve\n    ans = (ans + val) % MOD\n                        ^^^\nNameError: name 'MOD' is not defined\n\n\nTest Case 7 Failed:\n  Status: RE\n  Input:\n5 0\n1 3 2 6 4\n1 2 1\n1 4 0\n3 2 1\n2 5 0\n  Expected:\n45\n  Actual Output:\n\n  Error: Traceback (most recent call last):\n  File \"C:\\Users\\杨文韬\\AppData\\Local\\Temp\\tmpnhwp7d76\\solution.py\", line 123, in <module>\n    solve()\n  File \"C:\\Users\\杨文韬\\AppData\\Local\\Temp\\tmpnhwp7d76\\solution.py\", line 42, in solve\n    ans = (ans + val) % MOD\n                        ^^^\nNameError: name 'MOD' is not defined\n\n\nTest Case 8 Failed:\n  Status: RE\n  Input:\n3 1\n1 1 1\n1 2 1\n3 2 0\n  Expected:\n10\n  Actual Output:\n\n  Error: Traceback (most recent call last):\n  File \"C:\\Users\\杨文韬\\AppData\\Local\\Temp\\tmp1va9yako\\solution.py\", line 123, in <module>\n    solve()\n  File \"C:\\Users\\杨文韬\\AppData\\Local\\Temp\\tmp1va9yako\\solution.py\", line 42, in solve\n    ans = (ans + val) % MOD\n                        ^^^\nNameError: name 'MOD' is not defined\n\n\nTest Case 9 Failed:\n  Status: RE\n  Input:\n6 3\n1000000000 1000000000 1000000000 1000000000 1000000000 1000000000\n1 2 0\n2 3 1\n3 4 0\n4 5 1\n5 6 0\n  Expected:\n999999918\n  Actual Output:\n\n  Error: Traceback (most recent call last):\n  File \"C:\\Users\\杨文韬\\AppData\\Local\\Temp\\tmpn888iha5\\solution.py\", line 123, in <module>\n    solve()\n  File \"C:\\Users\\杨文韬\\AppData\\Local\\Temp\\tmpn888iha5\\solution.py\", line 42, in solve\n    ans = (ans + val) % MOD\n                        ^^^\nNameError: name 'MOD' is not defined\n\n",
    "tests": "```\nInput:\n2 0\n5 10\n1 2 0\n\nOutput:\n25\n```\n\n```\nInput:\n2 1\n5 10\n1 2 1\n\nOutput:\n25\n```\n\n```\nInput:\n3 0\n1 2 3\n1 2 0\n2 3 0\n\nOutput:\n20\n```\n\n```\nInput:\n3 1\n1 2 3\n1 2 0\n2 3 1\n\nOutput:\n23\n```\n\n```\nInput:\n4 1\n1 1 1 1\n1 2 0\n2 3 1\n3 4 0\n\nOutput:\n30\n```\n\n```\nInput:\n5 2\n0 0 0 0 0\n1 2 0\n2 3 1\n3 4 0\n4 5 1\n\nOutput:\n0\n```\n\n```\nInput:\n5 0\n1 3 2 6 4\n1 2 1\n1 4 0\n3 2 1\n2 5 0\n\nOutput:\n45\n```\n\n```\nInput:\n3 1\n1 1 1\n1 2 1\n3 2 0\n\nOutput:\n10\n```\n\n```\nInput:\n6 3\n1000000000 1000000000 1000000000 1000000000 1000000000 1000000000\n1 2 0\n2 3 1\n3 4 0\n4 5 1\n5 6 0\n\nOutput:\n999999918\n```",
    "test_report": "Input:\n2 0\n5 10\n1 2 0\n\nOutput:\n25\n"
  },
  "Round_3": {
    "code": "def solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    k = int(next(it))\n    a = [0] * n\n    for i in range(n):\n        a[i] = int(next(it))\n    \n    adj = [[] for _ in range(n)]\n    for _ in range(n-1):\n        u = int(next(it)) - 1\n        v = int(next(it)) - 1\n        t = int(next(it))\n        adj[u].append((v, t))\n        adj[v].append((u, t))\n    \n    removed = [False] * n\n    subtree_size = [0] * n\n    \n    def dfs_size(v, p):\n        subtree_size[v] = 1\n        for to, _ in adj[v]:\n            if to != p and not removed[to]:\n                dfs_size(to, v)\n                subtree_size[v] += subtree_size[to]\n    \n    def find_centroid(v, p, total):\n        for to, _ in adj[v]:\n            if to != p and not removed[to] and subtree_size[to] * 2 > total:\n                return find_centroid(to, v, total)\n        return v\n    \n    ans = 0\n    \n    # single vertex paths\n    for val in a:\n        ans = (ans + val) % MOD\n    \n    # paths through centroid\n    def process_centroid(centroid):\n        nonlocal ans\n        \n        # cnt[sw][col] = number of paths from centroid to some vertex\n        # sum_h[sw][col] = total happiness sum of those paths\n        cnt = [[0, 0] for _ in range(k+2)]\n        sum_h = [[0, 0] for _ in range(k+2)]\n        \n        # start with centroid itself (path of length 0)\n        cnt[0][0] = 1\n        sum_h[0][0] = a[centroid] % MOD\n        \n        for to, first_col in adj[centroid]:\n            if removed[to]:\n                continue\n            \n            # collect all paths in this subtree\n            paths = []  # (switches, last_color, happiness, count)\n            \n            stack = [(to, centroid, first_col, 0, a[to] + a[centroid], first_col)]\n            while stack:\n                v, p, last_col, sw, happiness, first_col = stack.pop()\n                # record this path\n                if sw <= k:\n                    paths.append((sw, last_col, happiness % MOD, 1))\n                # continue DFS\n                for nxt, edge_col in adj[v]:\n                    if nxt == p or removed[nxt]:\n                        continue\n                    new_sw = sw + (1 if edge_col != last_col else 0)\n                    new_happiness = happiness + a[nxt]\n                    stack.append((nxt, v, edge_col, new_sw, new_happiness, first_col))\n            \n            # combine with previous subtrees\n            for sw1, col1, h1, c1 in paths:\n                for sw2 in range(k+1):\n                    for col2 in range(2):\n                        c2 = cnt[sw2][col2]\n                        if c2 == 0:\n                            continue\n                        total_sw = sw1 + sw2\n                        if col1 != col2:\n                            total_sw += 1\n                        if total_sw <= k:\n                            # happiness contribution: (h1 + h2 - a[centroid]) * c1 * c2\n                            h2 = sum_h[sw2][col2]\n                            total_h = (h1 + h2 - a[centroid]) % MOD\n                            contribution = (total_h * c1) % MOD\n                            contribution = (contribution * c2) % MOD\n                            ans = (ans + contribution) % MOD\n            \n            # add current subtree paths to cnt/sum_h\n            for sw, col, h, c in paths:\n                cnt[sw][col] = (cnt[sw][col] + c) % MOD\n                sum_h[sw][col] = (sum_h[sw][col] + h) % MOD\n        \n        # add paths where centroid is one endpoint\n        total_h_all = 0\n        for sw in range(k+1):\n            for col in range(2):\n                total_h_all = (total_h_all + sum_h[sw][col]) % MOD\n        # subtract centroid itself (already counted as single vertex)\n        centroid_contrib = (total_h_all - a[centroid]) % MOD\n        ans = (ans + centroid_contrib) % MOD\n    \n    def decompose(v):\n        dfs_size(v, -1)\n        cent = find_centroid(v, -1, subtree_size[v])\n        process_centroid(cent)\n        removed[cent] = True\n        for to, _ in adj[cent]:\n            if not removed[to]:\n                decompose(to)\n    \n    decompose(0)\n    print(ans % MOD)"
  }
}