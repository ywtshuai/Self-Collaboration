{
  "plan": "```json\n{\n  \"input_output_format_analysis\": {\n    \"input_parsing\": \"First line: two integers n and k separated by space. Next n lines: each contains two integers x_i and y_i separated by space.\",\n    \"output_format\": \"Single real number r, printed with sufficient precision (at least 10 decimal places recommended).\",\n    \"special_requirements\": \"Absolute or relative error ≤ 1e-4. Output 0.0 if k=1 and one habitat at origin.\"\n  },\n  \"algorithm_design\": {\n    \"problem_type\": \"Computational geometry, optimization with binary search.\",\n    \"core_idea\": \"The park circle must touch origin (0,0), so its center is at distance exactly r from origin. For a given r, the center lies on a circle of radius r around origin. For each habitat point, we can compute the range of center positions (on that circle) that include the habitat inside the park. Then check if some center position covers at least k habitats.\",\n    \"step_by_step_approach\": [\n      \"Step 1: Read n, k and points.\",\n      \"Step 2: If k=1, answer is 0.0 (center at origin, radius 0).\",\n      \"Step 3: Binary search on radius r from 0 to 2e5 (upper bound given).\",\n      \"Step 4: For a given r, for each point (x,y):\",\n      \"  - Compute d = distance from origin to point.\",\n      \"  - If d > 2r, point cannot be inside any circle of radius r touching origin (since max distance from center to point is 2r when point opposite origin). Skip.\",\n      \"  - Else, compute angle α of point from origin using atan2(y,x).\",\n      \"  - Compute angular half-width θ = acos(d/(2r)) if d>0, else θ=π (if point at origin).\",\n      \"  - This gives angular interval [α-θ, α+θ] on the circle of radius r around origin where center can be to include point.\",\n      \"Step 5: Use sweep line on angles: wrap intervals around circle, check if any angular position is covered by ≥k intervals.\",\n      \"Step 6: If possible for current r, try smaller r; else try larger r.\",\n      \"Step 7: Output final r with required precision.\"\n    ],\n    \"time_complexity\": \"O(n log n log(ε^-1)) where ε is precision (1e-9 gives ~60 iterations).\",\n    \"space_complexity\": \"O(n) for storing intervals.\"\n  },\n  \"edge_cases_and_constraints\": {\n    \"minimum_input\": \"n=1, k=1, point at origin → r=0.\",\n    \"maximum_constraints\": \"n=1e5, coordinates up to 1e5, r up to 2e5.\",\n    \"special_values\": [\n      \"Points at origin: interval covers all angles.\",\n      \"Points with d > 2r: ignored.\",\n      \"k = n: need all points inside.\",\n      \"All points collinear or symmetric.\"\n    ],\n    \"boundary_conditions\": [\n      \"Angular wrap-around at 2π.\",\n      \"Precision in angle comparisons.\",\n      \"When d=0 (point at origin), θ=π (full circle).\"\n    ]\n  },\n  \"common_pitfalls\": [\n    \"Floating-point precision in binary search and angle calculations.\",\n    \"Not handling wrap-around correctly in interval sweep.\",\n    \"Missing case when point distance > 2r.\",\n    \"Using degrees instead of radians for trigonometric functions.\",\n    \"Incorrectly setting binary search bounds (lower bound 0, upper bound 2e5).\",\n    \"Forgetting that center is exactly at distance r from origin.\"\n  ]\n}\n```",
  "Round_0": {
    "code": "def solve() -> None:\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    k = int(next(it))\n    points = []\n    for _ in range(n):\n        x = int(next(it))\n        y = int(next(it))\n        points.append((x, y))\n    \n    if k == 1:\n        print(\"0.0000000000\")\n        return\n    \n    # Binary search on radius r\n    low, high = 0.0, 2e5\n    eps = 1e-7\n    while high - low > eps:\n        mid = (low + high) * 0.5\n        r = mid\n        \n        events = []\n        cnt = 0\n        for x, y in points:\n            d = math.hypot(x, y)\n            if d > 2 * r + 1e-12:\n                continue\n            if abs(d) < 1e-12:\n                # point at origin: always inside for any center\n                cnt += 1\n                continue\n            angle = math.atan2(y, x)\n            half_width = math.acos(d / (2 * r))\n            start = angle - half_width\n            end = angle + half_width\n            # wrap to [0, 2π)\n            if start < 0:\n                start += 2 * math.pi\n                end += 2 * math.pi\n            events.append((start, 1))\n            events.append((end, -1))\n            # add wrapped interval\n            events.append((start + 2 * math.pi, 1))\n            events.append((end + 2 * math.pi, -1))\n        \n        # sort events\n        events.sort()\n        # sweep\n        cur = cnt\n        possible = False\n        for _, typ in events:\n            cur += typ\n            if cur >= k:\n                possible = True\n                break\n        \n        if possible:\n            high = mid\n        else:\n            low = mid\n    \n    print(f\"{low:.10f}\")",
    "report": "The compilation output of the preceding code is: Test Case 2 Failed:\n  Status: WA\n  Input:\n2 2\n0 0\n0 0\n  Expected:\n0.0000000000\n  Actual Output:\n199999.9999999091\n  Error: \n\nTest Case 3 Failed:\n  Status: WA\n  Input:\n3 2\n0 0\n1 0\n-1 0\n  Expected:\n0.5000000000\n  Actual Output:\n0.4999999874\n  Error: \n\nTest Case 4 Failed:\n  Status: WA\n  Input:\n5 3\n0 0\n0 1\n0 -1\n1 0\n-1 0\n  Expected:\n0.5000000000\n  Actual Output:\n0.7071067557\n  Error: \n\nTest Case 5 Failed:\n  Status: WA\n  Input:\n4 4\n-100000 0\n100000 0\n0 -100000\n0 100000\n  Expected:\n100000.0000000000\n  Actual Output:\n199999.9999999091\n  Error: \n\nTest Case 6 Failed:\n  Status: WA\n  Input:\n6 4\n-3 1\n-4 4\n1 5\n2 2\n2 -2\n-2 -4\n  Expected:\n3.1622776589\n  Actual Output:\n3.1622776078\n  Error: \n\nTest Case 7 Failed:\n  Status: RE\n  Input:\n100000 50000\n0 0\n1 1\n2 2\n3 3\n4 4\n5 5\n6 6\n7 7\n8 8\n9 9\n10 10\n... (continuing pattern up to 100000 points with coordinates (i,i) for i=0..99999)\n  Expected:\n35355.0000000000\n  Actual Output:\n\n  Error: Traceback (most recent call last):\n  File \"C:\\Users\\杨文韬\\AppData\\Local\\Temp\\tmpnhu080xw\\solution.py\", line 71, in <module>\n    solve()\n  File \"C:\\Users\\杨文韬\\AppData\\Local\\Temp\\tmpnhu080xw\\solution.py\", line 13, in solve\n    x = int(next(it))\n        ^^^^^^^^^^^^^\nValueError: invalid literal for int() with base 10: '...'\n\n",
    "tests": "```\nInput:\n1 1\n0 0\n\nOutput:\n0.0000000000\n```\n\n```\nInput:\n2 2\n0 0\n0 0\n\nOutput:\n0.0000000000\n```\n\n```\nInput:\n3 2\n0 0\n1 0\n-1 0\n\nOutput:\n0.5000000000\n```\n\n```\nInput:\n5 3\n0 0\n0 1\n0 -1\n1 0\n-1 0\n\nOutput:\n0.5000000000\n```\n\n```\nInput:\n4 4\n-100000 0\n100000 0\n0 -100000\n0 100000\n\nOutput:\n100000.0000000000\n```\n\n```\nInput:\n6 4\n-3 1\n-4 4\n1 5\n2 2\n2 -2\n-2 -4\n\nOutput:\n3.1622776589\n```\n\n```\nInput:\n100000 50000\n0 0\n1 1\n2 2\n3 3\n4 4\n5 5\n6 6\n7 7\n8 8\n9 9\n10 10\n... (continuing pattern up to 100000 points with coordinates (i,i) for i=0..99999)\n\nOutput:\n35355.0000000000\n```",
    "test_report": "Input:\n1 1\n0 0\n\nOutput:\n0.0000000000\n"
  },
  "Round_1": {
    "code": "def solve() -> None:\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    k = int(next(it))\n    points = []\n    for _ in range(n):\n        x = int(next(it))\n        y = int(next(it))\n        points.append((x, y))\n    \n    if k == 1:\n        print(\"0.0000000000\")\n        return\n    \n    # Binary search on radius r\n    low, high = 0.0, 4e5  # Upper bound can be up to 2e5, but use 4e5 for safety\n    eps = 1e-7\n    \n    for _ in range(60):  # Fixed number of iterations for precision\n        mid = (low + high) * 0.5\n        r = mid\n        \n        if r < 1e-12:\n            # Special case: very small radius\n            cnt = 0\n            for x, y in points:\n                if abs(x) < 1e-12 and abs(y) < 1e-12:\n                    cnt += 1\n            if cnt >= k:\n                high = mid\n            else:\n                low = mid\n            continue\n        \n        events = []\n        origin_count = 0\n        \n        for x, y in points:\n            d = math.hypot(x, y)\n            if d < 1e-12:\n                origin_count += 1\n                continue\n            if d > 2 * r + 1e-12:\n                continue\n            \n            angle = math.atan2(y, x)\n            half_width = math.acos(min(1.0, d / (2 * r)))\n            start = angle - half_width\n            end = angle + half_width\n            \n            # Normalize to [0, 2π)\n            if start < 0:\n                start += 2 * math.pi\n                end += 2 * math.pi\n            \n            events.append((start, 1))\n            events.append((end, -1))\n            # Add wrapped copy\n            events.append((start + 2 * math.pi, 1))\n            events.append((end + 2 * math.pi, -1))\n        \n        # Sort events\n        events.sort()\n        \n        # Sweep line\n        cur = origin_count\n        possible = False\n        for _, typ in events:\n            cur += typ\n            if cur >= k:\n                possible = True\n                break\n        \n        if possible:\n            high = mid\n        else:\n            low = mid\n    \n    # Output with sufficient precision\n    print(f\"{low:.10f}\")",
    "report": "The compilation output of the preceding code is: Test Case 2 Failed:\n  Status: WA\n  Input:\n2 2\n0 0\n0 0\n  Expected:\n0.0000000000\n  Actual Output:\n199999.9999999091\n  Error: \n\nTest Case 3 Failed:\n  Status: WA\n  Input:\n3 2\n0 0\n1 0\n-1 0\n  Expected:\n0.5000000000\n  Actual Output:\n0.4999999874\n  Error: \n\nTest Case 4 Failed:\n  Status: WA\n  Input:\n5 3\n0 0\n0 1\n0 -1\n1 0\n-1 0\n  Expected:\n0.5000000000\n  Actual Output:\n0.7071067557\n  Error: \n\nTest Case 5 Failed:\n  Status: WA\n  Input:\n4 4\n-100000 0\n100000 0\n0 -100000\n0 100000\n  Expected:\n100000.0000000000\n  Actual Output:\n199999.9999999091\n  Error: \n\nTest Case 6 Failed:\n  Status: WA\n  Input:\n8 4\n-3 1\n-4 4\n1 5\n2 2\n2 -2\n-2 -4\n-1 -1\n-6 0\n  Expected:\n3.1622776589\n  Actual Output:\n3.1622776078\n  Error: \n\nTest Case 7 Failed:\n  Status: RE\n  Input:\n100000 1\n0 0\n1 1\n2 2\n3 3\n4 4\n5 5\n6 6\n7 7\n8 8\n9 9\n10 10\n... (continuing pattern up to 100000 points with coordinates (i,i) for i=0..99999)\n  Expected:\n0.0000000000\n  Actual Output:\n\n  Error: Traceback (most recent call last):\n  File \"C:\\Users\\杨文韬\\AppData\\Local\\Temp\\tmp5ccvkjfi\\solution.py\", line 71, in <module>\n    solve()\n  File \"C:\\Users\\杨文韬\\AppData\\Local\\Temp\\tmp5ccvkjfi\\solution.py\", line 13, in solve\n    x = int(next(it))\n        ^^^^^^^^^^^^^\nValueError: invalid literal for int() with base 10: '...'\n\n\nTest Case 8 Failed:\n  Status: RE\n  Input:\n100000 100000\n0 0\n0 0\n0 0\n... (100000 points all at origin)\n  Expected:\n0.0000000000\n  Actual Output:\n\n  Error: Traceback (most recent call last):\n  File \"C:\\Users\\杨文韬\\AppData\\Local\\Temp\\tmpsbh_t6c6\\solution.py\", line 71, in <module>\n    solve()\n  File \"C:\\Users\\杨文韬\\AppData\\Local\\Temp\\tmpsbh_t6c6\\solution.py\", line 13, in solve\n    x = int(next(it))\n        ^^^^^^^^^^^^^\nValueError: invalid literal for int() with base 10: '...'\n\n\nTest Case 9 Failed:\n  Status: RE\n  Input:\n100000 50000\n0 0\n100000 100000\n-100000 100000\n100000 -100000\n-100000 -100000\n... (remaining points randomly distributed within bounds)\n  Expected:\n<some value ≤ 200000.0000000000>\n  Actual Output:\n\n  Error: Traceback (most recent call last):\n  File \"C:\\Users\\杨文韬\\AppData\\Local\\Temp\\tmpwfwphsc3\\solution.py\", line 71, in <module>\n    solve()\n  File \"C:\\Users\\杨文韬\\AppData\\Local\\Temp\\tmpwfwphsc3\\solution.py\", line 13, in solve\n    x = int(next(it))\n        ^^^^^^^^^^^^^\nValueError: invalid literal for int() with base 10: '...'\n\n",
    "tests": "```\nInput:\n1 1\n0 0\n\nOutput:\n0.0000000000\n```\n\n```\nInput:\n2 2\n0 0\n0 0\n\nOutput:\n0.0000000000\n```\n\n```\nInput:\n3 2\n0 0\n1 0\n-1 0\n\nOutput:\n0.5000000000\n```\n\n```\nInput:\n5 3\n0 0\n0 1\n0 -1\n1 0\n-1 0\n\nOutput:\n0.5000000000\n```\n\n```\nInput:\n4 4\n-100000 0\n100000 0\n0 -100000\n0 100000\n\nOutput:\n100000.0000000000\n```\n\n```\nInput:\n8 4\n-3 1\n-4 4\n1 5\n2 2\n2 -2\n-2 -4\n-1 -1\n-6 0\n\nOutput:\n3.1622776589\n```\n\n```\nInput:\n100000 1\n0 0\n1 1\n2 2\n3 3\n4 4\n5 5\n6 6\n7 7\n8 8\n9 9\n10 10\n... (continuing pattern up to 100000 points with coordinates (i,i) for i=0..99999)\n\nOutput:\n0.0000000000\n```\n\n```\nInput:\n100000 100000\n0 0\n0 0\n0 0\n... (100000 points all at origin)\n\nOutput:\n0.0000000000\n```\n\n```\nInput:\n100000 50000\n0 0\n100000 100000\n-100000 100000\n100000 -100000\n-100000 -100000\n... (remaining points randomly distributed within bounds)\n\nOutput:\n<some value ≤ 200000.0000000000>\n```",
    "test_report": "Input:\n1 1\n0 0\n\nOutput:\n0.0000000000\n"
  },
  "Round_2": {
    "code": "def solve() -> None:\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    k = int(next(it))\n    points = []\n    for _ in range(n):\n        x = int(next(it))\n        y = int(next(it))\n        points.append((x, y))\n    \n    # Special case: if k == 1, answer is 0.0 (center at origin)\n    if k == 1:\n        print(\"0.0000000000\")\n        return\n    \n    # Binary search on radius r\n    low, high = 0.0, 4e5  # Upper bound can be up to 2e5, but use 4e5 for safety\n    eps = 1e-7\n    \n    for _ in range(60):  # Fixed number of iterations for precision\n        mid = (low + high) * 0.5\n        r = mid\n        \n        if r < 1e-12:\n            # Special case: very small radius\n            cnt = 0\n            for x, y in points:\n                if abs(x) < 1e-12 and abs(y) < 1e-12:\n                    cnt += 1\n            if cnt >= k:\n                high = mid\n            else:\n                low = mid\n            continue\n        \n        events = []\n        origin_count = 0\n        \n        for x, y in points:\n            d = math.hypot(x, y)\n            if d < 1e-12:\n                origin_count += 1\n                continue\n            if d > 2 * r + 1e-12:\n                continue\n            \n            angle = math.atan2(y, x)\n            half_width = math.acos(min(1.0, d / (2 * r)))\n            start = angle - half_width\n            end = angle + half_width\n            \n            # Normalize to [0, 2π)\n            if start < 0:\n                start += 2 * math.pi\n                end += 2 * math.pi\n            \n            events.append((start, 1))\n            events.append((end, -1))\n            # Add wrapped copy\n            events.append((start + 2 * math.pi, 1))\n            events.append((end + 2 * math.pi, -1))\n        \n        # Sort events\n        events.sort()\n        \n        # Sweep line\n        cur = origin_count\n        possible = False\n        for _, typ in events:\n            cur += typ\n            if cur >= k:\n                possible = True\n                break\n        \n        if possible:\n            high = mid\n        else:\n            low = mid\n    \n    # Output with sufficient precision\n    print(f\"{low:.10f}\")",
    "report": "The compilation output of the preceding code is: Test Case 2 Failed:\n  Status: WA\n  Input:\n2 2\n0 0\n0 0\n  Expected:\n0.0000000000\n  Actual Output:\n400000.0000000000\n  Error: \n\nTest Case 4 Failed:\n  Status: WA\n  Input:\n5 3\n0 0\n0 1\n0 -1\n1 0\n-1 0\n  Expected:\n0.5000000000\n  Actual Output:\n0.7071067812\n  Error: \n\nTest Case 5 Failed:\n  Status: WA\n  Input:\n4 4\n-100000 0\n100000 0\n0 -100000\n0 100000\n  Expected:\n100000.0000000000\n  Actual Output:\n400000.0000000000\n  Error: \n\nTest Case 6 Failed:\n  Status: WA\n  Input:\n8 4\n-3 1\n-4 4\n1 5\n2 2\n2 -2\n-2 -4\n-1 -1\n-6 0\n  Expected:\n3.1622776589\n  Actual Output:\n3.1622776602\n  Error: \n\nTest Case 7 Failed:\n  Status: RE\n  Input:\n100000 1\n0 0\n1 1\n2 2\n3 3\n4 4\n5 5\n6 6\n7 7\n8 8\n9 9\n10 10\n... (continuing pattern up to 100000 points with coordinates (i,i) for i=0..99999)\n  Expected:\n0.0000000000\n  Actual Output:\n\n  Error: Traceback (most recent call last):\n  File \"C:\\Users\\杨文韬\\AppData\\Local\\Temp\\tmpf_fkup9p\\solution.py\", line 89, in <module>\n    solve()\n  File \"C:\\Users\\杨文韬\\AppData\\Local\\Temp\\tmpf_fkup9p\\solution.py\", line 13, in solve\n    x = int(next(it))\n        ^^^^^^^^^^^^^\nValueError: invalid literal for int() with base 10: '...'\n\n\nTest Case 8 Failed:\n  Status: RE\n  Input:\n100000 100000\n0 0\n0 0\n0 0\n... (100000 points all at origin)\n  Expected:\n0.0000000000\n  Actual Output:\n\n  Error: Traceback (most recent call last):\n  File \"C:\\Users\\杨文韬\\AppData\\Local\\Temp\\tmpm30j5zru\\solution.py\", line 89, in <module>\n    solve()\n  File \"C:\\Users\\杨文韬\\AppData\\Local\\Temp\\tmpm30j5zru\\solution.py\", line 13, in solve\n    x = int(next(it))\n        ^^^^^^^^^^^^^\nValueError: invalid literal for int() with base 10: '...'\n\n\nTest Case 9 Failed:\n  Status: RE\n  Input:\n100000 50000\n0 0\n100000 100000\n-100000 100000\n100000 -100000\n-100000 -100000\n... (remaining points randomly distributed within bounds)\n  Expected:\n<some value ≤ 200000.0000000000>\n  Actual Output:\n\n  Error: Traceback (most recent call last):\n  File \"C:\\Users\\杨文韬\\AppData\\Local\\Temp\\tmpk63y7w8f\\solution.py\", line 89, in <module>\n    solve()\n  File \"C:\\Users\\杨文韬\\AppData\\Local\\Temp\\tmpk63y7w8f\\solution.py\", line 13, in solve\n    x = int(next(it))\n        ^^^^^^^^^^^^^\nValueError: invalid literal for int() with base 10: '...'\n\n",
    "tests": "```\nInput:\n1 1\n0 0\n\nOutput:\n0.0000000000\n```\n\n```\nInput:\n2 2\n0 0\n0 0\n\nOutput:\n0.0000000000\n```\n\n```\nInput:\n3 2\n0 0\n1 0\n-1 0\n\nOutput:\n0.5000000000\n```\n\n```\nInput:\n5 3\n0 0\n0 1\n0 -1\n1 0\n-1 0\n\nOutput:\n0.5000000000\n```\n\n```\nInput:\n4 4\n-100000 0\n100000 0\n0 -100000\n0 100000\n\nOutput:\n100000.0000000000\n```\n\n```\nInput:\n8 4\n-3 1\n-4 4\n1 5\n2 2\n2 -2\n-2 -4\n-1 -1\n-6 0\n\nOutput:\n3.1622776589\n```\n\n```\nInput:\n100000 1\n0 0\n1 1\n2 2\n3 3\n4 4\n5 5\n6 6\n7 7\n8 8\n9 9\n10 10\n... (continuing pattern up to 100000 points with coordinates (i,i) for i=0..99999)\n\nOutput:\n0.0000000000\n```\n\n```\nInput:\n100000 100000\n0 0\n0 0\n0 0\n... (100000 points all at origin)\n\nOutput:\n0.0000000000\n```\n\n```\nInput:\n100000 50000\n0 0\n100000 100000\n-100000 100000\n100000 -100000\n-100000 -100000\n... (remaining points randomly distributed within bounds)\n\nOutput:\n<some value ≤ 200000.0000000000>\n```",
    "test_report": "Input:\n1 1\n0 0\n\nOutput:\n0.0000000000\n"
  },
  "Round_3": {
    "code": "def solve() -> None:\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    k = int(next(it))\n    points = []\n    for _ in range(n):\n        x = int(next(it))\n        y = int(next(it))\n        points.append((x, y))\n    \n    # Special case: if k == 1, answer is 0.0 (center at origin)\n    if k == 1:\n        print(\"0.0000000000\")\n        return\n    \n    # Check if all points are at origin\n    all_origin = all(abs(x) == 0 and abs(y) == 0 for x, y in points)\n    if all_origin:\n        print(\"0.0000000000\")\n        return\n    \n    # Binary search on radius r\n    low, high = 0.0, 4e5  # Upper bound can be up to 2e5, but use 4e5 for safety\n    \n    for _ in range(60):  # Fixed number of iterations for precision\n        mid = (low + high) * 0.5\n        r = mid\n        \n        if r < 1e-12:\n            # Special case: very small radius\n            cnt = 0\n            for x, y in points:\n                if abs(x) < 1e-12 and abs(y) < 1e-12:\n                    cnt += 1\n            if cnt >= k:\n                high = mid\n            else:\n                low = mid\n            continue\n        \n        events = []\n        origin_count = 0\n        \n        for x, y in points:\n            d = math.hypot(x, y)\n            if d < 1e-12:\n                origin_count += 1\n                continue\n            if d > 2 * r + 1e-12:\n                continue\n            \n            angle = math.atan2(y, x)\n            half_width = math.acos(min(1.0, d / (2 * r)))\n            start = angle - half_width\n            end = angle + half_width\n            \n            # Normalize to [0, 2π)\n            if start < 0:\n                start += 2 * math.pi\n                end += 2 * math.pi\n            \n            events.append((start, 1))\n            events.append((end, -1))\n            # Add wrapped copy\n            events.append((start + 2 * math.pi, 1))\n            events.append((end + 2 * math.pi, -1))\n        \n        # Sort events\n        events.sort()\n        \n        # Sweep line\n        cur = origin_count\n        possible = False\n        for _, typ in events:\n            cur += typ\n            if cur >= k:\n                possible = True\n                break\n        \n        if possible:\n            high = mid\n        else:\n            low = mid\n    \n    # Output with sufficient precision\n    print(f\"{low:.10f}\")"
  }
}