{
  "pass_at_1": 20.0,
  "passed": 1,
  "total": 5,
  "time_cost_minutes": 15.892215581734975,
  "token_usage": 62593,
  "problems": [
    {
      "problem_id": "1575_A. Another Sorting Problem",
      "accuracy": 1.0,
      "solution": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    m = int(data[1])\n    strings = data[2:2 + n]\n    \n    # Store strings with their original 1-based indices\n    indexed_strings = [(strings[i], i + 1) for i in range(n)]\n    \n    # Custom comparator key function\n    def sort_key(item):\n        s = item[0]\n        # Build a tuple where each character's comparison order depends on position parity\n        # For odd positions (1-based) -> compare normally, so use ord(c)\n        # For even positions (1-based) -> compare reversed, so use -ord(c)\n        # Since we use 0-based indexing in Python:\n        #   position j (0-based) corresponds to 1-based position j+1\n        #   if j is even -> j+1 is odd -> normal order\n        #   if j is odd -> j+1 is even -> reversed order\n        return tuple(ord(s[j]) if j % 2 == 0 else -ord(s[j]) for j in range(m))\n    \n    # Sort using the custom key\n    indexed_strings.sort(key=sort_key)\n    \n    # Output the original indices\n    result = ' '.join(str(idx) for _, idx in indexed_strings)\n    sys.stdout.write(result)\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "problem_id": "1575_B. Building an Amusement Park",
      "accuracy": 0.3333333333333333,
      "solution": "import sys\nimport math\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    k = int(next(it))\n    points = []\n    for _ in range(n):\n        x = int(next(it))\n        y = int(next(it))\n        points.append((x, y))\n    \n    # If k is 1, the minimum radius is 0 (we can place center at origin)\n    if k == 1:\n        print(\"0.0000000000\")\n        return\n    \n    # Precompute distances from origin for each point\n    dists = [math.hypot(x, y) for x, y in points]\n    \n    # Binary search on radius\n    low = 0.0\n    high = 200000.0  # Given constraint\n    eps = 1e-7  # Higher precision for binary search\n    \n    for _ in range(60):  # Enough iterations for required precision\n        mid = (low + high) / 2\n        \n        # For each point, compute the angular interval where center can be placed\n        # such that the point is within distance mid from the center\n        intervals = []\n        for i in range(n):\n            d = dists[i]\n            if d > 2 * mid + eps:\n                # Point too far, no possible center\n                continue\n            if d <= eps:\n                # Point at origin, any center on circle of radius mid works\n                intervals.append((-math.pi, math.pi))\n                continue\n            \n            # Angle from origin to point\n            theta = math.atan2(points[i][1], points[i][0])\n            # Half-angle of the intersection\n            if d > mid:\n                # Law of cosines: mid^2 = mid^2 + d^2 - 2*mid*d*cos(alpha)\n                # Actually, we need angle at origin between point and center\n                # Using cosine rule: cos(alpha) = (mid^2 + d^2 - mid^2) / (2*mid*d) = d/(2*mid)\n                # But careful: we need the angular spread from theta\n                # The correct formula: delta = acos(d/(2*mid))\n                delta = math.acos(d / (2 * mid))\n            else:\n                # Point inside the circle centered at origin with radius mid\n                # The entire circle is covered\n                delta = math.pi\n            \n            # Interval is [theta - delta, theta + delta]\n            intervals.append((theta - delta, theta + delta))\n        \n        # Check if we can choose at least k intervals that overlap\n        # Sort by start angle\n        intervals.sort()\n        \n        # Duplicate intervals to handle circular nature\n        m = len(intervals)\n        for i in range(m):\n            start, end = intervals[i]\n            intervals.append((start + 2*math.pi, end + 2*math.pi))\n        \n        # Sweep line to find maximum overlap\n        found = False\n        j = 0\n        active = 0\n        for i in range(m):\n            # Remove intervals that end before current start\n            while j < len(intervals) and intervals[j][0] < intervals[i][0]:\n                j += 1\n                active -= 1\n            # Add intervals that start at or before current start\n            # Actually, we need to add all intervals that start <= current_start\n            # Let's reset and do proper sweep\n            pass\n        \n        # Better approach: for each interval as starting point, count how many overlap\n        best = 0\n        for i in range(m):\n            cnt = 1\n            end = intervals[i][1]\n            for j in range(i+1, len(intervals)):\n                if intervals[j][0] > end:\n                    break\n                if intervals[j][1] < end:\n                    end = intervals[j][1]\n                cnt += 1\n                if cnt >= k:\n                    best = k\n                    break\n            if best >= k:\n                break\n        \n        if best >= k:\n            high = mid\n        else:\n            low = mid\n    \n    print(f\"{high:.10f}\")\n\nif __name__ == \"__main__\":\n    solve()"
    },
    {
      "problem_id": "1575_C. Cyclic Sum",
      "accuracy": 0.0,
      "solution": "import sys\n\nMOD = 10**9 + 7\n\ndef solve() -> None:\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    m = int(next(it))\n    k = int(next(it))\n    a = [int(next(it)) for _ in range(n)]\n\n    total_sum = sum(a)\n    total_sum_mod = total_sum % k\n\n    # prefix sums modulo k for one copy of a\n    pref = [0] * (n + 1)\n    for i in range(n):\n        pref[i + 1] = (pref[i] + a[i]) % k\n\n    # count frequencies of each remainder in one copy\n    cnt_one = [0] * k\n    for i in range(1, n + 1):  # exclude pref[0] for now\n        cnt_one[pref[i]] += 1\n\n    # total number of segments in the cyclic sequence of length N = n * m\n    N = n * m\n\n    # Case 1: k == 1\n    if k == 1:\n        # every segment sum is divisible by 1\n        # total number of segments in a cyclic sequence of length N is N * N\n        ans = (N % MOD) * (N % MOD) % MOD\n        print(ans)\n        return\n\n    # For k prime, we use the approach described in the editorial\n    # We need to count pairs (i, j) with 0 <= i < j <= N such that\n    # (pref[j] - pref[i]) % k == 0, i.e., pref[i] == pref[j]\n    # But we must consider the cyclic nature: indices wrap modulo n.\n\n    # Let S = total_sum % k\n    # The prefix sums for the t-th copy (0-indexed) are:\n    #   pref[t*n + i] = (t * S + pref[i]) % k   for i = 0..n\n    # where pref[i] are the prefixes within one copy (i from 0 to n)\n\n    # We need to count pairs (x, y) with 0 <= x < y <= N such that\n    # pref[x] == pref[y].\n\n    # Let’s count for each remainder r how many indices have that remainder.\n    # The number of indices with remainder r is:\n    #   cnt[r] = m * cnt_one[r] + (1 if r == 0 else 0)\n    # because pref[0] = 0 appears once per full cycle? Wait, careful.\n\n    # Actually, pref[0] = 0 appears at the start of each full concatenation?\n    # Let's think: b is m copies of a.\n    # The prefix sums are:\n    #   at index 0: 0\n    #   at index 1..n: pref[1]..pref[n] (first copy)\n    #   at index n+1..2n: (S + pref[1]) % k .. (S + pref[n]) % k\n    #   ...\n    #   at index (m-1)*n+1 .. m*n: ((m-1)*S + pref[1]) % k .. ((m-1)*S + pref[n]) % k\n\n    # So the set of prefix sums (including index 0) is:\n    #   {0} ∪ { (t*S + pref[i]) % k | t = 0..m-1, i = 1..n }\n\n    # Let’s compute for each remainder r the count of indices with that remainder.\n    cnt = [0] * k\n    # index 0 has remainder 0\n    cnt[0] += 1\n\n    # For each t from 0 to m-1, and each i from 1 to n\n    # remainder = (t*S + pref[i]) % k\n    # We can aggregate by counting for each possible pref[i] value how many t give a certain remainder.\n\n    # For a fixed p = pref[i], the remainders as t varies are:\n    #   (t*S + p) % k\n    # Since k is prime and S may be 0, we handle cases.\n\n    if total_sum_mod == 0:\n        # Then (t*S + p) % k = p % k for all t\n        # So each pref[i] appears m times.\n        for i in range(1, n + 1):\n            cnt[pref[i]] += m\n    else:\n        # S != 0, and k prime => S has multiplicative inverse mod k.\n        # The sequence (t*S + p) mod k as t runs from 0 to m-1 is an arithmetic progression mod k.\n        # It will visit each remainder at most once per cycle of length k, but m may be larger.\n        # We can think: we want to count, for each remainder r, how many t in [0, m-1] satisfy\n        #   (t*S + p) ≡ r (mod k)\n        # => t ≡ (r - p) * inv(S) (mod k)\n        # Let invS be the modular inverse of S modulo k.\n        # Then t ≡ (r - p) * invS (mod k)\n        # So in the range [0, m-1], the number of such t is:\n        #   floor((m - 1 - t0) / k) + 1 if t0 <= m-1 else 0,\n        # where t0 is the smallest nonnegative integer congruent to that value.\n        # But we can compute directly:\n        #   count = (m + (k - t0 % k)) // k   ... not exactly.\n\n        # Actually, since k is prime and S != 0, the map t -> (t*S + p) mod k is a permutation for t mod k.\n        # So as t runs from 0 to m-1, each remainder appears exactly floor(m/k) times,\n        # and then the first m % k remainders in the cycle starting from p appear one more time.\n\n        # Let’s compute for each p = pref[i] the set of remainders that appear.\n        # We can precompute for each p the counts.\n\n        invS = pow(total_sum_mod, k - 2, k)  # Fermat's little theorem\n\n        # We'll create an array add[r] that we will add to cnt[r] for each occurrence of p.\n        # But we need to do this for each p efficiently.\n\n        # For each p, the sequence of remainders for t=0..m-1 is:\n        #   r_t = (t*S + p) % k\n        # Let’s define start = p\n        # Then r_t = (start + t*S) % k\n        # This is a cycle of length k (since S != 0).\n        # In m steps, each remainder appears floor(m/k) times,\n        # and the first (m mod k) remainders in the cycle appear one more time.\n\n        # So for a given p, we can compute:\n        #   base = m // k\n        #   extra = m % k\n        #   Then for each remainder r, the count from this p is base + (1 if r is among the first extra in the cycle else 0)\n        # The cycle order: start, start+S, start+2S, ... mod k.\n\n        # We can compute for each p the list of first extra remainders.\n        # Since n and k up to 2e5, we cannot do O(n * k).\n\n        # Alternative: note that for each p, the extra remainders are:\n        #   (p + j*S) % k for j = 0..extra-1\n        # So we can, for each p, add base to cnt[r] for all r, and then add 1 to cnt[(p + j*S)%k] for j=0..extra-1.\n        # Adding base to all r for each p is too heavy.\n\n        # Better: first, each p contributes base to every remainder. So total from all p:\n        #   total_base = n * base\n        #   We can add total_base to each cnt[r] later.\n\n        base = m // k\n        extra = m % k\n        total_base = n * base\n\n        # Now for the extra part:\n        # For each p, we need to add 1 to cnt[(p + j*S) % k] for j=0..extra-1.\n        # We can do this by iterating over p and j, but that's O(n * extra) which could be O(n*k) worst case.\n\n        # Since extra < k <= 2e5, and n <= 2e5, O(n * extra) could be 4e10 worst case, too big.\n\n        # We need a smarter way.\n        # Let’s define an array freq_p[r] = number of i (1<=i<=n) such that pref[i] == r.\n        freq_p = [0] * k\n        for i in range(1, n + 1):\n            freq_p[pref[i]] += 1\n\n        # Now for each remainder r, we want to know how many p and j give (p + j*S) % k == r.\n        # For a fixed j, p must be (r - j*S) % k.\n        # So cnt[r] gets an extra contribution of freq_p[(r - j*S) % k] for each j=0..extra-1.\n        # So we can compute for each r:\n        #   extra_contrib[r] = sum_{j=0}^{extra-1} freq_p[(r - j*S) % k]\n\n        # We can compute this convolution-like sum using prefix sums or by iterating j.\n        # Since extra <= k <= 2e5, we can compute in O(k * extra) which is O(k^2) worst case, still too big.\n\n        # Wait, we can compute extra_contrib efficiently by noting that as j increases, (r - j*S) mod k goes backwards in steps of S.\n        # So for each r, the sequence is r, r-S, r-2S, ... mod k.\n        # This is a cycle of length k.\n        # So extra_contrib[r] is the sum of freq_p over a contiguous block of length extra in this cycle.\n        # We can compute for all r using sliding window.\n\n        # Let’s create an array arr of length k: arr[i] = freq_p[i].\n        # We want for each r: sum_{j=0}^{extra-1} arr[(r - j*S) % k]\n        # Let’s define idx = (r - j*S) % k. As j increases, idx decreases by S mod k.\n        # So for fixed r, the indices are r, r-S, r-2S, ... mod k.\n        # This is not a contiguous segment in the natural order unless S=1.\n        # But we can reorder the array by multiplying indices by invS.\n        # Let invS be the inverse of S mod k.\n        # Consider mapping remainder x to pos = (x * invS) % k.\n        # Then (r - j*S) * invS ≡ r*invS - j (mod k).\n        # So in the pos space, the indices for a given r are: pos0 = r*invS, then pos0-1, pos0-2, ... mod k.\n        # That is a contiguous segment (in cyclic sense) of length extra.\n\n        # So we can transform freq_p to an array f where f[pos] = freq_p[(pos * S) % k]? Wait.\n        # We have: pos = x * invS % k  => x = pos * S % k.\n        # So f[pos] = freq_p[pos * S % k].\n\n        # Then extra_contrib[r] = sum_{j=0}^{extra-1} freq_p[(r - j*S) % k]\n        # Let pos_r = r * invS % k.\n        # Then (r - j*S) * invS ≡ pos_r - j (mod k).\n        # So extra_contrib[r] = sum_{j=0}^{extra-1} f[(pos_r - j) % k]\n        # That is the sum of f over a contiguous block of length extra ending at pos_r (in cyclic order).\n\n        # So we can compute f, then compute its prefix sums, and then for each r compute the sum of f over the window of length extra ending at pos_r.\n\n        f = [0] * k\n        for pos in range(k):\n            x = (pos * total_sum_mod) % k\n            f[pos] = freq_p[x]\n\n        # Now compute prefix sums of f for cyclic sliding window.\n        # We can double the array to handle cyclic.\n        f_double = f + f\n        pref_f = [0] * (2 * k + 1)\n        for i in range(2 * k):\n            pref_f[i + 1] = pref_f[i] + f_double[i]\n\n        extra_contrib = [0] * k\n        for r in range(k):\n            pos_r = (r * invS) % k\n            # window of length extra ending at pos_r: from pos_r - extra + 1 to pos_r inclusive.\n            start = pos_r - extra + 1\n            if start < 0:\n                # use the doubled array\n                start += k\n                end = start + extra - 1\n                s = pref_f[end + 1] - pref_f[start]\n            else:\n                s = pref_f[pos_r + 1] - pref_f[start]\n            extra_contrib[r] = s\n\n        # Now we can compute cnt[r] for r=0..k-1:\n        # cnt[r] = 1 (for index 0) + total_base + extra_contrib[r]\n        for r in range(k):\n            cnt[r] = (1 + total_base + extra_contrib[r]) % MOD  # we only need modulo MOD for final computation, but cnt values can be large.\n\n    else:\n        # total_sum_mod == 0 case\n        for r in range(k):\n            cnt[r] = (cnt[r] + cnt_one[r] * m) % MOD\n\n    # Now we have cnt[r] = number of indices with prefix sum remainder r.\n    # The number of pairs (i, j) with i < j and pref[i] == pref[j] is sum_{r} C(cnt[r], 2).\n    ans = 0\n    for r in range(k):\n        c = cnt[r]\n        ans = (ans + c * (c - 1) // 2) % MOD\n\n    print(ans % MOD)\n\nif __name__ == \"__main__\":\n    solve()"
    },
    {
      "problem_id": "1575_D. Divisible by Twenty-Five",
      "accuracy": 0.7432432432432432,
      "solution": "import sys\n\ndef solve() -> None:\n    s = sys.stdin.readline().strip()\n    n = len(s)\n    \n    # Count X and underscore positions\n    x_positions = [i for i, ch in enumerate(s) if ch == 'X']\n    underscore_positions = [i for i, ch in enumerate(s) if ch == '_']\n    \n    # If there are no X and no underscore, just check if the number is divisible by 25\n    if not x_positions and not underscore_positions:\n        if int(s) % 25 == 0 and (s == '0' or s[0] != '0'):\n            print(1)\n        else:\n            print(0)\n        return\n    \n    # Generate all possible assignments for X (0-9)\n    x_assignments = []\n    for x_digit in range(10):\n        x_assignments.append(x_digit)\n    \n    # Generate all possible endings for divisibility by 25\n    endings = []\n    for i in range(10):\n        for j in range(10):\n            num = i * 10 + j\n            if num % 25 == 0:\n                endings.append((str(i), str(j)))\n    \n    total = 0\n    \n    # Try each X assignment\n    for x_digit in x_assignments:\n        # Build base string with X replaced\n        base_list = list(s)\n        for pos in x_positions:\n            base_list[pos] = str(x_digit)\n        \n        # Try each ending\n        for end1, end2 in endings:\n            # Create a copy for this ending\n            current = base_list.copy()\n            \n            # Check if we can assign the last two positions\n            # We need to handle positions from right to left\n            valid = True\n            # First check the last two positions\n            for offset, required_digit in enumerate([end2, end1], 1):\n                pos = n - offset\n                if pos < 0:\n                    valid = False\n                    break\n                if current[pos] == '_':\n                    current[pos] = required_digit\n                elif current[pos] == 'X':\n                    # Already replaced with x_digit, check if it matches\n                    if current[pos] != required_digit:\n                        valid = False\n                        break\n                else:  # fixed digit\n                    if current[pos] != required_digit:\n                        valid = False\n                        break\n            \n            if not valid:\n                continue\n            \n            # Now fill remaining underscores with any digit 0-9\n            # But need to avoid leading zeros\n            remaining_underscores = [i for i in underscore_positions if current[i] == '_']\n            \n            # Count possibilities for remaining underscores\n            # First position cannot be 0 unless the entire number is \"0\"\n            first_pos = 0\n            while first_pos < n and current[first_pos] == '0':\n                first_pos += 1\n            \n            # If all digits are 0, then it's only valid if the string is exactly \"0\"\n            if all(ch == '0' for ch in current if ch != '_'):\n                # Check if we can make it exactly \"0\"\n                if n == 1 and (s[0] == '_' or s[0] == 'X' or s[0] == '0'):\n                    total += 1\n                continue\n            \n            # Check leading zero constraint\n            if current[0] == '0':\n                # Leading zero not allowed (except for single digit 0 which we handled above)\n                continue\n            \n            # For remaining underscores, they can be any digit 0-9\n            # But if the first character is underscore, it cannot be 0\n            count = 1\n            for pos in remaining_underscores:\n                if pos == 0:\n                    count *= 9  # 1-9\n                else:\n                    count *= 10  # 0-9\n            \n            total += count\n    \n    print(total)\n\nif __name__ == \"__main__\":\n    solve()"
    },
    {
      "problem_id": "1575_E. Eye-Pleasing City Park Tour",
      "accuracy": 0.0,
      "solution": "import sys\nsys.setrecursionlimit(300000)\nMOD = 10**9 + 7\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    k = int(next(it))\n    a = [0] + [int(next(it)) % MOD for _ in range(n)]\n    \n    adj = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        u = int(next(it))\n        v = int(next(it))\n        t = int(next(it))\n        adj[u].append((v, t))\n        adj[v].append((u, t))\n    \n    # dp[u][c][d]: number of paths starting at u with first edge color c (0 or 1) and d color changes\n    # sumdp[u][c][d]: sum of happiness values of all such paths\n    dp = [[[0] * (k + 2) for _ in range(2)] for _ in range(n + 1)]\n    sumdp = [[[0] * (k + 2) for _ in range(2)] for _ in range(n + 1)]\n    \n    ans = 0\n    \n    def dfs(u, p):\n        nonlocal ans\n        # Single vertex path\n        ans = (ans + a[u]) % MOD\n        \n        for v, col in adj[u]:\n            if v == p:\n                continue\n            dfs(v, u)\n            \n            # Merge subtree v into u\n            for d1 in range(k + 1):\n                for c1 in range(2):\n                    if dp[u][c1][d1] == 0 and sumdp[u][c1][d1] == 0:\n                        continue\n                    for d2 in range(k + 1):\n                        for c2 in range(2):\n                            if dp[v][c2][d2] == 0 and sumdp[v][c2][d2] == 0:\n                                continue\n                            # Connect paths from u and v through edge (u,v)\n                            # Paths from u are already rooted at u, paths from v are rooted at v\n                            # When connecting, we need to consider the edge color col\n                            # For paths from v, the first edge color is c2\n                            # So when connecting to u, the color change at the junction is:\n                            # if c1 != col: already counted in d1\n                            # if col != c2: need to add 1 change\n                            total_changes = d1 + d2\n                            if col != c2:\n                                total_changes += 1\n                            if total_changes > k:\n                                continue\n                            \n                            # Number of combined paths\n                            cnt = dp[u][c1][d1] * dp[v][c2][d2] % MOD\n                            if cnt == 0:\n                                continue\n                            \n                            # Sum of happiness values:\n                            # For each path from u (sum_u) and path from v (sum_v),\n                            # Combined path sum = sum_u + sum_v\n                            # But sum_v already includes a[v] and all vertices in its path\n                            # We need to add a[u] to the combined path? Actually paths from u already include a[u]\n                            # And paths from v already include a[v]\n                            # The combined path is: (path from u) + edge(u,v) + (path from v)\n                            # So total sum = sum_u + sum_v\n                            # But wait: paths from u are rooted at u and include a[u]\n                            # paths from v are rooted at v and include a[v]\n                            # The combined path includes both a[u] and a[v], so sum_u + sum_v is correct\n                            sum_u = sumdp[u][c1][d1]\n                            sum_v = sumdp[v][c2][d2]\n                            total_sum = (sum_u * dp[v][c2][d2] + sum_v * dp[u][c1][d1]) % MOD\n                            \n                            ans = (ans + total_sum) % MOD\n            \n            # Now update dp[u] with paths that start at u and go into subtree v\n            # Two cases:\n            # 1. Path that is just the edge (u,v) - single edge path\n            #    This path has first edge color col, 0 changes\n            dp[u][col][0] = (dp[u][col][0] + 1) % MOD\n            sumdp[u][col][0] = (sumdp[u][col][0] + a[u] + a[v]) % MOD\n            \n            # 2. Paths that start at u, go through edge (u,v), then continue with paths from v\n            for d in range(k + 1):\n                for c in range(2):\n                    if dp[v][c][d] == 0 and sumdp[v][c][d] == 0:\n                        continue\n                    # When we go from u to v with edge color col, then follow path from v with first color c\n                    changes = d\n                    if col != c:\n                        changes += 1\n                    if changes > k:\n                        continue\n                    \n                    # Number of such paths\n                    cnt = dp[v][c][d]\n                    # Sum of happiness values: a[u] + (sum of path from v)\n                    # But sumdp[v][c][d] already includes a[v] and all vertices in its path\n                    path_sum = (a[u] * cnt + sumdp[v][c][d]) % MOD\n                    \n                    dp[u][col][changes] = (dp[u][col][changes] + cnt) % MOD\n                    sumdp[u][col][changes] = (sumdp[u][col][changes] + path_sum) % MOD\n    \n    dfs(1, 0)\n    print(ans % MOD)\n\nif __name__ == \"__main__\":\n    solve()"
    }
  ]
}